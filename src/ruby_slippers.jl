################################################################################
# Â© Copyright 2022-2023 Zapata Computing Inc.
################################################################################
#=
This module contains functions for getting the graph state corresponding to a
state generated by a circuit using a graph state simulator (graph_sim) from the paper
"Fast simulation of stabilizer circuits using a graph state representation" by Simon
Anders, Hans J. Briegel. https://arxiv.org/abs/quant-ph/0504117". We have modified
the algorithm to ignore paulis.

Many of the modules have a no_teleport version. This is to denote that the compiler
does not use teleportation in these cases and is more or less just it's predicessor,
a graph simulator for stabilizer states.
=#

using PythonCall
using StatsBase
import .pauli_tracker: Frames, Storage

include("graph_sim_data.jl")

const AdjList = Set{Int32}

const Qubit = UInt32

struct ICMOp
    code::UInt8
    qubit1::Qubit
    qubit2::Qubit

    ICMOp(name, qubit) = new(name, qubit, 0)
    ICMOp(name, qubit1, qubit2) = new(name, qubit1, qubit2)
end

struct RubySlippersHyperparams
    teleportation_threshold::UInt16
    teleportation_distance::UInt8
    min_neighbors::UInt8
    max_num_neighbors_to_search::UInt32
    decomposition_strategy::UInt8 # TODO: make pauli tracker work witn decomposition_strategy=1
end

default_hyperparams = RubySlippersHyperparams(3, 6, 6, 1e5, 0)
graphsim_hyperparams(min_neighbors, max_num_neighbors_to_search) = RubySlippersHyperparams(65535, 2, min_neighbors, max_num_neighbors_to_search, 0)
default_graphsim_hyperparams = graphsim_hyperparams(6, 1e5)

"""
Data on the aglortihm specific graph state. During computation, this
struct may contain more nodes than are actually used in the graph state.
At the end of the computation, the data structures are resized to only
contain the nodes which are actually used in the graph state. A lack
of input and output nodes indicate that this graph is not stitchable.

Attributes:
    edge_data (Vector{AdjList}): adjacency list describing the graph
    sqs (Vector{UInt8}): single qubit clifford operations on each node
    sqp (Vector{UInt8}): single qubit pauli operations on each node
    data_nodes (Vector{Qubit}): nodes which are currently acted on by the circuit
    n_nodes (UInt32): number of nodes being used by the graph state
    input_nodes (Uint32): when stitching, connect these nodes to
        the previous graph in the sequence. Defaults to empy list
        when graph is not stichable
    input_nodes (Uint32): when stitching, connect these nodes to
        the next graph in the sequence. Defaults to empy list
        when graph is not stichable
"""
mutable struct AlgorithmSpecificGraph
    edge_data::Vector{AdjList}
    sqs::Vector{UInt8}
    sqp::Vector{UInt8}
    data_nodes::Vector{Qubit} # nodes where the data is currently stored
    n_nodes::UInt32
    input_nodes::Vector{Qubit} # nodes to connect to graph when stitching
    output_nodes::Vector{Qubit} # nodes to connect to graph when stitching
end
# Create a graph with all qubits initialized to the |0> state.
AlgorithmSpecificGraphAllZero(max_graph_size, n_qubits) = AlgorithmSpecificGraph(
    [AdjList() for _ = 1:max_graph_size],
    fill(H_code, max_graph_size),
    fill(I_code, max_graph_size),
    [Qubit(i) for i = 1:n_qubits],
    n_qubits,
    [],
    [],
)

mutable struct PauliTrackerData
    frames::Ptr{Frames}
    frames_map::Vector{Int}
    storage::Ptr{Storage}
    measurements::Vector{Tuple{UInt8,Int64}}

    PauliTrackerData(frames, storage) = new(frames, [], storage, [])
end
function PauliTrackerData(n_qubits::Int)
    frames = pauli_tracker.frames_init(UInt(n_qubits))
    storage = pauli_tracker.storage_new()
    PauliTrackerData(frames, storage)
end


function apply_gate(frames::Ptr{Frames}, icm_op)
    qubit1 = UInt64(icm_op.qubit1 - 1)

    if icm_op.code == H_code
        pauli_tracker.frames_h(frames, qubit1)
    elseif icm_op.code == S_code
        pauli_tracker.frames_s(frames, qubit1)
    elseif icm_op.code == CZ_code
        qubit2 = UInt64(icm_op.qubit2 - 1)
        pauli_tracker.frames_cz(frames, qubit1, qubit2)
    elseif icm_op.code in [I_code, X_code, Y_code, Z_code]
        # do nothing
    elseif icm_op.code == S_code
        pauli_tracker.frames_sdg(frames, qubit1)
    elseif icm_op.code == CNOT_code
        qubit2 = UInt64(icm_op.qubit2 - 1)
        pauli_tracker.frames_cx(frames, qubit1, qubit2)
    else
        error("Unknown gate: $(icm_op.code)")
    end
end

"""
Converts a given circuit in Clifford + T form to icm form and simulates the icm
circuit using the graph sim mini simulator. Returns the adjacency list of the graph
state created by the icm circuit along with the single qubit operations on each vertex.
teleportation_threshold, min_neighbors, teleportation_distance, and  max_num_neighbors_to_search
are metaparameters which can be optimized to speed up the simulation.

Args:
    circuit::Circuit                  circuit to be simulated
    max_graph_size::Int               maximum number of nodes in the graph state
    teleportation_threshold::Int      max node degree allowed before state is teleported
    teleportation_distance::Int       number of teleportations to do when state is teleported
    min_neighbors::Int                stop searching for neighbor with low degree if
                                        neighbor has at least this many neighbors
    max_num_neighbors_to_search::Int  max number of neighbors to search through when finding
                                        a neighbor with low degree
    decomposition_strategy::Int       strategy for decomposing non-clifford gate
                                        0: keep current qubit as data qubit
                                        1: teleport data to new qubit which becomes data qubit

Returns:
    adj::Vector{AdjList}              adjacency list describing the graph state
    sqs::Vector{UInt8}                  single qubit clifford operations on each node
"""
function run_ruby_slippers(
    circuit,
    verbose=false,
    max_graph_size=nothing,
    teleportation_threshold=40,
    teleportation_distance=4,
    min_neighbors=6,
    max_num_neighbors_to_search=1e5,
    decomposition_strategy=1,
    max_time=1e8
)
    # params which can be optimized to speed up computation
    hyperparams = RubySlippersHyperparams(
        teleportation_threshold,
        teleportation_distance,
        min_neighbors,
        max_num_neighbors_to_search,
        decomposition_strategy,
    )

    if max_graph_size === nothing
        max_graph_size = get_max_n_nodes(circuit, hyperparams.teleportation_distance)
    else
        max_graph_size = pyconvert(UInt32, max_graph_size)
    end

    if verbose
        # print("get_graph_state_data:\t")
        (sqc, adj, proportion) = @time get_graph_state_data(circuit, true, max_graph_size, hyperparams, max_time)
    else
        (sqc, adj, proportion) = get_graph_state_data(circuit, false, max_graph_size, hyperparams, max_time)
    end
    return pylist(sqc), python_adjlist!(adj), proportion
end

function get_max_n_nodes(circuit, teleportation_distance)
    supported_ops = get_op_list()

    n_magic_state_injection_teleports = 0
    n_ruby_slippers_teleports = 0

    for op in circuit.operations
        if false # occursin("ResetOperation", pyconvert(String, op.__str__()))
            n_magic_state_injection_teleports += 1
            continue
        else
            op_index = get_op_index(supported_ops, op)
            if double_qubit_op(op_index)
                n_ruby_slippers_teleports += 2
            elseif decompose_op(op_index)
                n_magic_state_injection_teleports += 1
                n_ruby_slippers_teleports += 1
            end
        end
    end

    return convert(UInt32, n_magic_state_injection_teleports +
                           n_ruby_slippers_teleports * teleportation_distance +
                           pyconvert(Int, circuit.n_qubits))
end

"""
Get the vertices of a graph state corresponding to enacting the given circuit
on the |0> state. Also gives the single qubit clifford operation on each node.

Args:
    circuit (Circuit): orquestra circuit circuit to get the graph state for
    verbose (Bool): whether to print progress
    hyperparams (Dict): metaparameters for the ruby slippers algorithm see
                        description in run_ruby_slippers for more details

Raises:
    ValueError: if an unsupported gate is encountered

Returns:
    Vector{UInt8}: the list of single qubit clifford operations on each node
    Vector{AdjList}:   the adjacency list describing the graph corresponding to the graph state
"""
function get_graph_state_data(
    ops,
    n_qubits,
    verbose::Bool=true,
    max_graph_size::UInt32=UInt32(1e7),
    max_time::Float64=1e8,
    buffer_length::Int=0,
    hyperparams::RubySlippersHyperparams=default_hyperparams,
)
    # println(ops)

    if buffer_length % 2 != 0
        error("Buffer size must be even.")
    end
    if buffer_length > 0
        asg = AlgorithmSpecificGraphAllZero(max_graph_size, 1)
        pauli_tracker_data = PauliTrackerData(1)
        # add buffer qubits to the graph state
        for i = 1:n_qubits
            asg.sqs[asg.n_nodes] = H_code
            asg.sqp[asg.n_nodes] = I_code
            teleportation!(
                asg,
                last(asg.data_nodes),
                pauli_tracker_data,
                hyperparams,
                buffer_length,
            )
            if i != n_qubits
                asg.n_nodes += 1
                push!(asg.data_nodes, Qubit(asg.n_nodes))
                pauli_tracker.frames_new_qubit(pauli_tracker_data.frames, UInt(asg.n_nodes) - 1)
            end
        end
    else
        asg = AlgorithmSpecificGraphAllZero(max_graph_size, n_qubits)
        pauli_tracker_data = PauliTrackerData(n_qubits)
    end


    total_length = length(ops)
    counter = dispcnt = 0
    erase = "        \b\b\b\b\b\b\b\b"

    start_time = time()
    for (i, op) in enumerate(ops)
        elapsed = time() - start_time
        if elapsed >= max_time
            # get rid of excess space in the data structures
            resize!(asg.sqs, asg.n_nodes)
            resize!(asg.sqp, asg.n_nodes)
            resize!(asg.edge_data, asg.n_nodes)

            proportion = i / total_length

            return asg.sqs, asg.edge_data, proportion
        end

        counter += 1
        if verbose
            if (dispcnt += 1) >= 1000
                percent = round(Int, 100 * counter / total_length)
                display_elapsed = round(elapsed, digits=2)
                # print("\r$(percent)% ($counter) completed in $erase$(display_elapsed)s")
                dispcnt = 0
            end
        end

        if false # occursin("ResetOperation", pyconvert(String, op.__str__()))
            asg.n_nodes += 1
            # data_qubits[get_qubit_1(op)] = asg.n_nodes
            continue
        else
            # Decomposes gates into the icm format.
            # Reference: https://arxiv.org/abs/1509.02004
            # println("applying operation ", op, " with data nodes ", asg.data_nodes)
            if op.code in [T_code, T_Dagger_code, RZ_code]
                # Note: these are currently all single qubit gates
                original_qubit = op.qubit1
                compiled_qubit = asg.data_nodes[original_qubit]
                asg.n_nodes += 1
                # println(compiled_qubit, " -> ", asg.n_nodes, " ")

                # TODO: what does this look like for the different decomposition_strategies?
                qubit_1 = UInt(compiled_qubit)
                qubit_2 = UInt(asg.n_nodes)

                # add new qubit to be tracked
                pauli_tracker.frames_new_qubit(pauli_tracker_data.frames, qubit_2 - 1)
                # apply CX
                multiply_h_from_left(asg, pauli_tracker_data, qubit_2)
                cz(asg, qubit_1, qubit_2, pauli_tracker_data, hyperparams)
                qubit_1 = UInt(asg.data_nodes[original_qubit]) # update qubit_1 to the new qubit if that cz teleported it
                multiply_h_from_left(asg, pauli_tracker_data, qubit_2)
                if hyperparams.decomposition_strategy == 0
                    asg.data_nodes[original_qubit] = qubit_2
                end
                # pauli_tracker.frames_measure_and_store(frames, qubit_1 - 1, storage)
                # pauli_tracker.frames_move_z_to_z(pauli_tracker_data.frames, qubit_1 - 1, qubit_2 - 1)
                pauli_tracker.frames_track_z(pauli_tracker_data.frames, qubit_2 - 1)
                push!(pauli_tracker_data.frames_map, qubit_1 - 1)
                push!(pauli_tracker_data.measurements, (op.code, qubit_1 - 1))
            elseif op.code in [I_code, X_code, Y_code, Z_code, H_code, S_code]
                op_code = op.code
                qubit_1 = asg.data_nodes[op.qubit1]
                if op_code in [I_code, X_code, Y_code, Z_code]
                    asg.sqp[qubit_1] = multiply_sqp[asg.sqp[qubit_1], external_to_internal_paulis[op_code]]
                elseif op_code == H_code
                    multiply_h_from_left(asg, pauli_tracker_data, qubit_1)
                elseif op_code == S_code
                    multiply_s_from_left(asg, pauli_tracker_data, qubit_1)
                end
            elseif op.code in [CZ_code, CNOT_code]
                op_code = op.code
                qubit_1 = asg.data_nodes[op.qubit1]
                qubit_2 = asg.data_nodes[op.qubit2]
                if op_code == CNOT_code
                    # CNOT = (I â H) CZ (I â H)
                    multiply_h_from_left(asg, pauli_tracker_data, qubit_2)
                    cz(asg, qubit_1, qubit_2, pauli_tracker_data, hyperparams)
                    qubit_2 = asg.data_nodes[op.qubit2] # update qubit_2 to the new qubit if that cz teleported it
                    multiply_h_from_left(asg, pauli_tracker_data, qubit_2)
                elseif op_code == CZ_code
                    cz(asg, qubit_1, qubit_2, pauli_tracker_data, hyperparams)
                end
            else
                error("Unsupported gate: $(op.code)")
            end
        end
    end

    if verbose
        elapsed = round(time() - start_time, digits=2)
        # println("\r100% ($counter) completed in $erase$(elapsed)s")
    end


    #TODO: Get rid of excess paulis being tracked!
    # turn excess buffer into isolated nodes which are ignored
    if buffer_length > 0
        # add teleportations at end so we can connect to next buffer
        for qubit in asg.data_nodes
            teleportation!(
                asg,
                qubit,
                pauli_tracker_data,
                hyperparams,
                4,
            )
            push!(asg.output_nodes, asg.n_nodes - 3)
            push!(asg.output_nodes, asg.n_nodes - 4)
            remove_edge!(asg.edge_data, asg.n_nodes, asg.n_nodes - 1)
            remove_edge!(asg.edge_data, asg.n_nodes - 1, asg.n_nodes - 2)
        end

        for i = 1:n_qubits
            buffer_start = (i - 1) * (buffer_length + 1) + 3
            buffer_end = i * (buffer_length + 1) # +1 to include the data qubit
            correct_sqs_start = asg.sqs[buffer_start] == H_code && asg.sqs[buffer_start+1] == H_code
            correct_sqp_start = asg.sqp[buffer_start] == I_code && asg.sqs[buffer_start+1] == I_code
            correct_adj_start = asg.edge_data[buffer_start+1] == Set([buffer_start + 1, buffer_start - 1]) && asg.edge_data[buffer_start] == Set([buffer_start + 1])
            if correct_sqs_start && correct_sqp_start && correct_adj_start
                throw(DomainError("Buffer size Exceeded!"))
            end
            adj_consumed = false
            sqs_consumed = false
            sqp_consumed = false
            for j = buffer_start:2:buffer_end
                adj_consumed = asg.edge_data[j+1] != Set([j + 2, j]) || asg.edge_data[j] != Set([j + 1, j - 1])
                sqs_consumed = asg.sqs[j+1] != H_code || asg.sqs[j] != H_code
                sqp_consumed = asg.sqp[j+1] != I_code || asg.sqp[j] != I_code
                println("$(j): $adj_consumed, $sqp_consumed, $sqp_consumed")
                if !adj_consumed || !sqs_consumed || !sqp_consumed
                    remove_edge!(asg.edge_data, j, j - 1)
                    remove_edge!(asg.edge_data, j - 1, j - 2)
                else
                    push!(asg.input_nodes, j - 1)
                    push!(asg.input_nodes, j - 2)
                    break
                end
            end
        end
    end

    # get rid of excess space in the data structures
    resize!(asg.edge_data, asg.n_nodes)
    resize!(asg.sqs, asg.n_nodes)
    resize!(asg.sqp, asg.n_nodes)

    return asg, pauli_tracker_data
end

"""
Check if a vertex is almost isolated. A vertex is almost isolated if it has no
neighbors or if it has one neighbor and that neighbor is the given vertex.

Args:
    set::AdjList set of neighbors of a vertex
    vertex::Int  vertex to check if it is almost isolated

Returns:
    Bool: whether the vertex is almost isolated
"""
function check_almost_isolated(set, vertex)
    len = length(set)
    return (len == 0) || (len == 1 && vertex in set)
end

"""
Apply a CZ gate to the graph on the given vertices.

Args:
    sqs::Vector{UInt8}      single qubit clifford operation on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    vertex_1::Int         vertex to enact the CZ gate on
    vertex_2::Int         vertex to enact the CZ gate on
"""
function cz(asg, vertex_1, vertex_2, pauli_tracker_data, hyperparams)
    # println("\nStarting applying cz on qubits $(vertex_1) and $(vertex_2)! the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n pauli       $(asg.sqp)!")
    # println(asg.data_nodes)


    adj1, adj2 = asg.edge_data[vertex_1], asg.edge_data[vertex_2]

    if length(asg.edge_data[vertex_1]) >= hyperparams.teleportation_threshold
        distance = hyperparams.teleportation_distance
        vertex_1 = teleportation!(asg, vertex_1, pauli_tracker_data, hyperparams, distance)
    end
    if length(asg.edge_data[vertex_2]) >= hyperparams.teleportation_threshold
        distance = hyperparams.teleportation_distance
        vertex_2 = teleportation!(asg, vertex_2, pauli_tracker_data, hyperparams, distance)
    end

    if !check_almost_isolated(adj1, vertex_2)
        remove_sqs!(asg, vertex_1, vertex_2, pauli_tracker_data, hyperparams)
    end
    if !check_almost_isolated(adj2, vertex_1)
        remove_sqs!(asg, vertex_2, vertex_1, pauli_tracker_data, hyperparams)
    end
    if !check_almost_isolated(adj1, vertex_2)
        remove_sqs!(asg, vertex_1, vertex_2, pauli_tracker_data, hyperparams)
    end

    # if check_almost_isolated(adj1, vertex_2)
    #     check_almost_isolated(adj2, vertex_1) ||
    #         remove_sqs!(asg, vertex_2, vertex_1, pauli_tracker_data, hyperparams)
    #     # if you don't remove vertex_2 from adj1, then you don't need to check again
    # else
    #     remove_sqs!(asg, vertex_1, vertex_2, pauli_tracker_data, hyperparams)
    #     if !check_almost_isolated(adj2, vertex_1)
    #         remove_sqs!(asg, vertex_2, vertex_1, pauli_tracker_data, hyperparams)
    #         # recheck the adjacency list of vertex_1, because it might have been removed
    #         check_almost_isolated(adj1, vertex_2) ||
    #             remove_sqs!(asg, vertex_1, vertex_2, pauli_tracker_data, hyperparams)
    #     end
    # end

    apply_cz_to_prepared_state(asg, vertex_1, vertex_2, pauli_tracker_data)
end

function cz_no_teleport(asg, vertex_1, vertex_2, pauli_tracker_data, hyperparams)
    # println("\nStarting applying cz_no_teleport! on qubits $(vertex_1) and $(vertex_2)! the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n pauli       $(asg.sqp)!")

    adj1, adj2 = asg.edge_data[vertex_1], asg.edge_data[vertex_2]

    if !check_almost_isolated(adj1, vertex_2)
        remove_sqs_no_teleport!(asg, vertex_1, vertex_2, hyperparams)
    end
    if !check_almost_isolated(adj2, vertex_1)
        remove_sqs_no_teleport!(asg, vertex_2, vertex_1, hyperparams)
    end
    if !check_almost_isolated(adj1, vertex_2)
        remove_sqs_no_teleport!(asg, vertex_1, vertex_2, hyperparams)
    end

    # if check_almost_isolated(adj1, vertex_2)
    #     check_almost_isolated(adj2, vertex_1) ||
    #         remove_sqs_no_teleport!(asg, vertex_2, vertex_1, hyperparams)
    #     # if you don't remove vertex_2 from adj1, then you don't need to check again
    # else
    #     remove_sqs_no_teleport!(asg, vertex_1, vertex_2, hyperparams)
    #     if !check_almost_isolated(adj2, vertex_1)
    #         remove_sqs_no_teleport!(asg, vertex_2, vertex_1, hyperparams)
    #         # recheck the adjacency list of vertex_1, because it might have been removed
    #         check_almost_isolated(adj1, vertex_2) ||
    #             remove_sqs_no_teleport!(asg, vertex_1, vertex_2, hyperparams)
    #     end
    # end

    apply_cz_to_prepared_state(asg, vertex_1, vertex_2, pauli_tracker_data)
end

"""
Assuming that the verticies CZ is acting on are either isolated or have sqs = I or S,
apply a CZ gate between those two gates. Only requires using lookup table.
"""
function apply_cz_to_prepared_state(asg, vertex_1, vertex_2, pauli_tracker_data)
    apply_gate(pauli_tracker_data.frames, ICMOp(CZ_code, vertex_1, vertex_2))

    # println("\nFinally applying cz on qubits $(vertex_1) and $(vertex_2)! the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n paulis      $(asg.sqp)!")

    connected = vertex_1 in asg.edge_data[vertex_2] || vertex_2 in asg.edge_data[vertex_1]

    clifford_1_table_code = asg.sqp[vertex_1] + 4 * (asg.sqs[vertex_1] - 1)
    clifford_2_table_code = asg.sqp[vertex_2] + 4 * (asg.sqs[vertex_2] - 1)
    table_tuple = cz_table[connected+1][clifford_1_table_code, clifford_2_table_code]

    # print("table_tuple is $(table_tuple)!\n")
    # print("table_tuple input was $(connected) and $clifford_1_table_code and $clifford_2_table_code \n")

    connected != table_tuple[1] && toggle_edge!(asg.edge_data, vertex_1, vertex_2)
    asg.sqp[vertex_1] = table_tuple[2][1]
    asg.sqs[vertex_1] = table_tuple[2][2]
    asg.sqp[vertex_2] = table_tuple[3][1]
    asg.sqs[vertex_2] = table_tuple[3][2]

    # println("After applying cz the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n paulis      $(asg.sqp)!")
end


"""
Remove all single qubit clifford operations on a vertex v that do not
commute with CZ. Needs use of a neighbor of v, but if we wish to avoid
using a particular neighbor, we can specify it.

Args:
    sqs::Vector{UInt8}      single qubit clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    v::Int                index of the vertex to remove single qubit clifford operations from
    avoid::Int            index of a neighbor of v to avoid using
"""
function remove_sqs!(asg, v, avoid, pauli_tracker_data, hyperparams)
    # println("remove_sqs at node $v ! to remove $(asg.sqs[v]) with pauli $(asg.sqp[v])!")
    # println("remove_sqs at node $v ! the prepared graph state is:\n edge data $(asg.edge_data)\n symplectics $(asg.sqs)\n pauli $(asg.sqp)!")
    code = asg.sqs[v]
    if code == I_code || code == S_code
    elseif code == SQRT_X_code || code == HS_code
        local_complement_no_teleport!(asg, v)
    else # code == H_code || code == SH_code
        # almost all calls to remove_sqs!() will end up here
        neighbor = get_neighbor(asg.edge_data, v, avoid, hyperparams)
        local_complement_no_teleport!(asg, neighbor)
        local_complement_no_teleport!(asg, v)
    end
    # println("sqs at node $v is now $(asg.sqs[v]) with pauli $(asg.sqp[v])!")
end

function remove_sqs_no_teleport!(asg, v, avoid, hyperparams)
    code = asg.sqs[v]
    if code == I_code || code == S_code
    elseif code == SQRT_X_code || code == HS_code
        local_complement_no_teleport!(asg, v)
    else # code == H_code || code == SH_code
        # almost all calls to remove_sqs!() will end up here
        neighbor = get_neighbor(asg.edge_data, v, avoid, hyperparams)
        local_complement_no_teleport!(asg, neighbor)
        local_complement_no_teleport!(asg, v)
    end
end

"""
Select a neighbor to use when removing a single qubit clifford operation.

The return value be set to avoid if there are no neighbors or avoid is the only neighbor,
otherwise it returns the neighbor with the fewest neighbors (or the first one that
it finds with less than min_neighbors)
"""
function get_neighbor(adj, v, avoid, hyperparams)
    neighbors_of_v = adj[v]

    # Avoid copying and modifying adjacency vector
    check_almost_isolated(neighbors_of_v, avoid) && return avoid

    smallest_neighborhood_size = typemax(eltype(neighbors_of_v)) # initialize to max possible value
    neighbor_with_smallest_neighborhood = 0
    if length(neighbors_of_v) <= hyperparams.max_num_neighbors_to_search
        neighbors_to_search = neighbors_of_v
    else
        neighbors_to_search = sample(
            collect(neighbors_of_v),
            hyperparams.max_num_neighbors_to_search;
            replace=false
        )
    end

    for neighbor in neighbors_to_search
        if neighbor != avoid
            # stop search if super small neighborhood is found
            num_neighbors = length(adj[neighbor])
            num_neighbors < hyperparams.min_neighbors && return neighbor
            # search for smallest neighborhood
            if num_neighbors < smallest_neighborhood_size
                smallest_neighborhood_size = num_neighbors
                neighbor_with_smallest_neighborhood = neighbor
            end
        end
    end
    return neighbor_with_smallest_neighborhood
end


"""
Take the local complement of a vertex v.

Args:
    sqs::Vector{UInt8}      single qubit clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    v::Int                index node to take the local complement of
"""
function local_complement!(asg, v, pauli_tracker_data, hyperparams)
    if length(asg.edge_data[v]) >= hyperparams.teleportation_threshold
        distance = hyperparams.teleportation_distance
        v = teleportation!(asg, v, pauli_tracker_data, hyperparams, distance)
    end

    local_complement_no_teleport!(asg, v)
end

function local_complement_no_teleport!(asg, v)
    # println("Before local complement on $(v) the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n paulis      $(asg.sqp)!")
    neighbors = collect(asg.edge_data[v])
    len = length(neighbors)
    multiply_sqrt_x_from_right(asg, v)
    for i = 1:len
        neighbor = neighbors[i]
        multiply_s_dagger_from_right(asg, neighbor)
        for j = i+1:len
            toggle_edge!(asg.edge_data, neighbor, neighbors[j])
        end
    end
    # println("After local complement on $(v) the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n paulis      $(asg.sqp)!")
end


"""Add an edge between the two vertices given"""
@inline function add_edge!(adj, vertex_1, vertex_2)
    push!(adj[vertex_1], vertex_2)
    push!(adj[vertex_2], vertex_1)
end

"""Remove an edge between the two vertices given"""
@inline function remove_edge!(adj, vertex_1, vertex_2)
    delete!(adj[vertex_1], vertex_2)
    delete!(adj[vertex_2], vertex_1)
end

"""
If vertices vertex_1 and vertex_2 are connected, we remove the edge.
Otherwise, add it.

Args:
    adj::Vector{AdjList}  adjacency list describing the graph state
    vertex_1::Int         index of vertex to be connected or disconnected
    vertex_2::Int         index of vertex to be connected or disconnected
"""
function toggle_edge!(adj, vertex_1, vertex_2)
    if vertex_2 in adj[vertex_1]
        remove_edge!(adj, vertex_1, vertex_2)
    else
        add_edge!(adj, vertex_1, vertex_2)
    end
end

"""
Teleport your "oz qubit" with high degree to a "kansas qubit" with degree 1.
Speeds up computation by avoiding performing local complements on high degree nodes.

Args:
    sqs::Vector{UInt8}      single qubit clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    oz_qubit::Int         index of the qubit to teleport
    data_qubits::Dict       map from qubit indices to vertex indices
"""
function teleportation!(
    asg,
    oz_qubit,
    pauli_tracker_data,
    hyperparams,
    curr_teleportation_distance,
)
    # println("\n\n\nThere's no place like home! There's no place like home! There's no place like home!")
    slippers_qubit = Qubit(asg.n_nodes + 1) # facilitates teleportation
    kansas_qubit = Qubit(asg.n_nodes + 2) # qubit we teleport to
    asg.n_nodes += 2
    # println("oz_qubit is $(oz_qubit) and slippers_qubit is $(slippers_qubit) and kansas_qubit is $(kansas_qubit)!\n\n\n")
    pauli_tracker.frames_new_qubit(pauli_tracker_data.frames, UInt(slippers_qubit) - 1)
    pauli_tracker.frames_new_qubit(pauli_tracker_data.frames, UInt(kansas_qubit) - 1)

    # # prepare bell state
    # multiply_h_from_left(asg, pauli_tracker_data, slippers_qubit)
    # multiply_h_from_left(asg, pauli_tracker_data, kansas_qubit)
    # cz_no_teleport(asg, kansas_qubit, slippers_qubit, pauli_tracker_data, hyperparams)
    # multiply_h_from_left(asg, pauli_tracker_data, kansas_qubit)

    # # teleport
    # multiply_h_from_left(asg, pauli_tracker_data, slippers_qubit)

    asg.sqs[slippers_qubit] = I_code
    asg.sqs[kansas_qubit] = I_code
    asg.edge_data[slippers_qubit] = AdjList(kansas_qubit)
    asg.edge_data[kansas_qubit] = AdjList(slippers_qubit)

    cz_no_teleport(asg, oz_qubit, slippers_qubit, pauli_tracker_data, hyperparams)
    multiply_h_from_left(asg, pauli_tracker_data, slippers_qubit)
    multiply_h_from_left(asg, pauli_tracker_data, oz_qubit)

    # TODO why does the frames_move_x_to_x cause problems with teleportation?
    # pauli_tracker.frames_move_x_to_x(pauli_tracker_data.frames, UInt(slippers_qubit) - 1, UInt(kansas_qubit) - 1)
    pauli_tracker.frames_track_x(pauli_tracker_data.frames, UInt(kansas_qubit) - 1)
    push!(pauli_tracker_data.frames_map, UInt(slippers_qubit) - 1)
    push!(pauli_tracker_data.measurements, (H_code, UInt(slippers_qubit) - 1))
    # pauli_tracker.frames_move_z_to_z(pauli_tracker_data.frames, UInt(oz_qubit) - 1, UInt(kansas_qubit) - 1)
    pauli_tracker.frames_track_z(pauli_tracker_data.frames, UInt(kansas_qubit) - 1)
    push!(pauli_tracker_data.frames_map, UInt(oz_qubit) - 1)
    push!(pauli_tracker_data.measurements, (H_code, UInt(oz_qubit) - 1))

    # update qubit map if needed
    for (i, qubit) in enumerate(asg.data_nodes)
        # println(qubit, " ", oz_qubit, " ", kansas_qubit)
        if qubit == oz_qubit
            asg.data_nodes[i] = kansas_qubit
        end
    end

    # println(asg.data_nodes)

    # peform multiple teleportations if we need distance > 2
    if curr_teleportation_distance > 2
        distance = curr_teleportation_distance - 2
        return teleportation!(asg, kansas_qubit, pauli_tracker_data, hyperparams, distance)
    end

    return kansas_qubit
end



#=
Some small utils for converting from python objects to Julia
=#

"""Get qubit index of python operation"""
get_qubit_1(op) = pyconvert(Int, op.qubit_indices[0]) + 1 # +1 because Julia is 1-indexed
get_qubit_2(op) = pyconvert(Int, op.qubit_indices[1]) + 1

"""Get Python version of op_list of to speed up getting index"""
get_op_list() = pylist(op_list)

"""Get index of operation name"""
get_op_index(op_list, op) = pyconvert(Int, op_list.index(op.gate.name)) + 1

pauli_op(index) = 0 <= index < 7 # i.e. I, X, Y, Z
single_qubit_op(index) = index < 10   # Paulis, H, S, S_Dagger
double_qubit_op(index) = 10 <= index < 12  # CZ, CNOT
decompose_op(index) = index >= 12 # T, T_Dagger, RX, RY, RZ

"""
Destructively convert this to a Python adjacency list
"""
function python_adjlist!(adj)
    pylist([pylist(adj[i] .- 1) for i = 1:length(adj)])
end
